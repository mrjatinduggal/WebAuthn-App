"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@levischuck";
exports.ids = ["vendor-chunks/@levischuck"];
exports.modules = {

/***/ "(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js":
/*!*************************************************************!*\
  !*** ./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CBORTag: () => (/* binding */ CBORTag),\n/* harmony export */   decodeCBOR: () => (/* binding */ decodeCBOR),\n/* harmony export */   decodePartialCBOR: () => (/* binding */ decodePartialCBOR),\n/* harmony export */   encodeCBOR: () => (/* binding */ encodeCBOR)\n/* harmony export */ });\n/* harmony import */ var _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cbor_internal.js */ \"(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js\");\n\n/**\n * A value which is wrapped with a CBOR Tag.\n * Several tags are registered with defined meanings like 0 for a date string.\n * These meanings are **not interpreted** when decoded or encoded.\n *\n * This class is an immutable record.\n * If the tag number or value needs to change, then construct a new tag\n */\nclass CBORTag {\n    /**\n     * Wrap a value with a tag number.\n     * When encoded, this tag will be attached to the value.\n     *\n     * @param tag Tag number\n     * @param value Wrapped value\n     */\n    constructor(tag, value) {\n        Object.defineProperty(this, \"tagId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tagValue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tagId = tag;\n        this.tagValue = value;\n    }\n    /**\n     * Read the tag number\n     */\n    get tag() {\n        return this.tagId;\n    }\n    /**\n     * Read the value\n     */\n    get value() {\n        return this.tagValue;\n    }\n}\nfunction decodeUnsignedInteger(data, argument, index) {\n    return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n}\nfunction decodeNegativeInteger(data, argument, index) {\n    const [value, length] = decodeUnsignedInteger(data, argument, index);\n    return [-value - 1, length];\n}\nfunction decodeByteString(data, argument, index) {\n    const [lengthValue, lengthConsumed] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    const dataStartIndex = index + lengthConsumed;\n    return [\n        new Uint8Array(data.buffer.slice(dataStartIndex, dataStartIndex + lengthValue)),\n        lengthConsumed + lengthValue,\n    ];\n}\nconst TEXT_DECODER = new TextDecoder();\nfunction decodeString(data, argument, index) {\n    const [value, length] = decodeByteString(data, argument, index);\n    return [TEXT_DECODER.decode(value), length];\n}\nfunction decodeArray(data, argument, index) {\n    if (argument === 0) {\n        return [[], 1];\n    }\n    const [length, lengthConsumed] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    let consumedLength = lengthConsumed;\n    const value = [];\n    for (let i = 0; i < length; i++) {\n        const remainingDataLength = data.byteLength - index - consumedLength;\n        if (remainingDataLength <= 0) {\n            throw new Error(\"array is not supported or well formed\");\n        }\n        const [decodedValue, consumed] = decodeNext(data, index + consumedLength);\n        value.push(decodedValue);\n        consumedLength += consumed;\n    }\n    return [value, consumedLength];\n}\nconst MAP_ERROR = \"Map is not supported or well formed\";\nfunction decodeMap(data, argument, index) {\n    if (argument === 0) {\n        return [new Map(), 1];\n    }\n    const [length, lengthConsumed] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    let consumedLength = lengthConsumed;\n    const result = new Map();\n    for (let i = 0; i < length; i++) {\n        let remainingDataLength = data.byteLength - index - consumedLength;\n        if (remainingDataLength <= 0) {\n            throw new Error(MAP_ERROR);\n        }\n        // Load key\n        const [key, keyConsumed] = decodeNext(data, index + consumedLength);\n        consumedLength += keyConsumed;\n        remainingDataLength -= keyConsumed;\n        // Check that there's enough to have a value\n        if (remainingDataLength <= 0) {\n            throw new Error(MAP_ERROR);\n        }\n        // Technically CBOR maps can have any type as the key, and so can JS Maps\n        // However, JS Maps can only reference such keys as references which would\n        // require key iteration and pattern matching.\n        // For simplicity, since such keys are not in use with WebAuthn, this\n        // capability is not implemented and the types are restricted to strings\n        // and numbers.\n        if (typeof key !== \"string\" && typeof key !== \"number\") {\n            throw new Error(MAP_ERROR);\n        }\n        // CBOR Maps are not well formed if there are duplicate keys\n        if (result.has(key)) {\n            throw new Error(MAP_ERROR);\n        }\n        // Load value\n        const [value, valueConsumed] = decodeNext(data, index + consumedLength);\n        consumedLength += valueConsumed;\n        result.set(key, value);\n    }\n    return [result, consumedLength];\n}\nfunction decodeFloat16(data, index) {\n    if (index + 3 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 16\");\n    }\n    // Skip the first byte\n    const result = data.getUint16(index + 1, false);\n    // A minimal selection of supported values\n    if (result == 0x7c00) {\n        return [Infinity, 3];\n    }\n    else if (result == 0x7e00) {\n        return [NaN, 3];\n    }\n    else if (result == 0xfc00) {\n        return [-Infinity, 3];\n    }\n    throw new Error(\"Float16 data is unsupported\");\n}\nfunction decodeFloat32(data, index) {\n    if (index + 5 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 32\");\n    }\n    // Skip the first byte\n    const result = data.getFloat32(index + 1, false);\n    // First byte + 4 byte float\n    return [result, 5];\n}\nfunction decodeFloat64(data, index) {\n    if (index + 9 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 64\");\n    }\n    // Skip the first byte\n    const result = data.getFloat64(index + 1, false);\n    // First byte + 8 byte float\n    return [result, 9];\n}\nfunction decodeTag(data, argument, index) {\n    const [tag, tagBytes] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    const [value, valueBytes] = decodeNext(data, index + tagBytes);\n    return [new CBORTag(tag, value), tagBytes + valueBytes];\n}\nfunction decodeNext(data, index) {\n    if (index >= data.byteLength) {\n        throw new Error(\"CBOR stream ended before tag value\");\n    }\n    const byte = data.getUint8(index);\n    const majorType = byte >> 5;\n    const argument = byte & 0x1f;\n    switch (majorType) {\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_UNSIGNED_INTEGER: {\n            return decodeUnsignedInteger(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_NEGATIVE_INTEGER: {\n            return decodeNegativeInteger(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_BYTE_STRING: {\n            return decodeByteString(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TEXT_STRING: {\n            return decodeString(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_ARRAY: {\n            return decodeArray(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_MAP: {\n            return decodeMap(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TAG: {\n            return decodeTag(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_SIMPLE_OR_FLOAT: {\n            switch (argument) {\n                case 20:\n                    return [false, 1];\n                case 21:\n                    return [true, 1];\n                case 22:\n                    return [null, 1];\n                case 23:\n                    return [undefined, 1];\n                // 24: Simple value (value 32..255 in following byte)\n                case 25: // IEEE 754 Half-Precision Float (16 bits follow)\n                    return decodeFloat16(data, index);\n                case 26: // IEEE 754 Single-Precision Float (32 bits follow)\n                    return decodeFloat32(data, index);\n                case 27: // IEEE 754 Double-Precision Float (64 bits follow)\n                    return decodeFloat64(data, index);\n                // 28-30: Reserved, not well-formed in the present document\n                // 31: \"break\" stop code for indefinite-length items\n            }\n        }\n    }\n    throw new Error(`Unsupported or not well formed at ${index}`);\n}\nfunction encodeSimple(data) {\n    if (data === true) {\n        return 0xf5;\n    }\n    else if (data === false) {\n        return 0xf4;\n    }\n    else if (data === null) {\n        return 0xf6;\n    }\n    // Else undefined\n    return 0xf7;\n}\nfunction encodeFloat(data) {\n    if (Math.fround(data) == data || !Number.isFinite(data) || Number.isNaN(data)) {\n        // Float32\n        const output = new Uint8Array(5);\n        output[0] = 0xfa;\n        const view = new DataView(output.buffer);\n        view.setFloat32(1, data, false);\n        return output;\n    }\n    else {\n        // Float64\n        const output = new Uint8Array(9);\n        output[0] = 0xfb;\n        const view = new DataView(output.buffer);\n        view.setFloat64(1, data, false);\n        return output;\n    }\n}\nfunction encodeNumber(data) {\n    if (typeof data == \"number\") {\n        if (Number.isSafeInteger(data)) {\n            // Encode integer\n            if (data < 0) {\n                return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_NEGATIVE_INTEGER, Math.abs(data));\n            }\n            else {\n                return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_UNSIGNED_INTEGER, data);\n            }\n        }\n        return [encodeFloat(data)];\n    }\n    else {\n        if (data < 0n) {\n            return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_NEGATIVE_INTEGER, data * -1n);\n        }\n        else {\n            return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_UNSIGNED_INTEGER, data);\n        }\n    }\n}\nconst ENCODER = new TextEncoder();\nfunction encodeString(data, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TEXT_STRING, data.length));\n    output.push(ENCODER.encode(data));\n}\nfunction encodeBytes(data, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_BYTE_STRING, data.length));\n    output.push(data);\n}\nfunction encodeArray(data, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_ARRAY, data.length));\n    for (const element of data) {\n        encodePartialCBOR(element, output);\n    }\n}\nfunction encodeMap(data, output) {\n    output.push(new Uint8Array((0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_MAP, data.size)));\n    for (const [key, value] of data.entries()) {\n        encodePartialCBOR(key, output);\n        encodePartialCBOR(value, output);\n    }\n}\nfunction encodeTag(tag, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TAG, tag.tag));\n    encodePartialCBOR(tag.value, output);\n}\nfunction encodePartialCBOR(data, output) {\n    if (typeof data == \"boolean\" || data === null || data == undefined) {\n        output.push(encodeSimple(data));\n        return;\n    }\n    if (typeof data == \"number\" || typeof data == \"bigint\") {\n        output.push(...encodeNumber(data));\n        return;\n    }\n    if (typeof data == \"string\") {\n        encodeString(data, output);\n        return;\n    }\n    if (data instanceof Uint8Array) {\n        encodeBytes(data, output);\n        return;\n    }\n    if (Array.isArray(data)) {\n        encodeArray(data, output);\n        return;\n    }\n    if (data instanceof Map) {\n        encodeMap(data, output);\n        return;\n    }\n    if (data instanceof CBORTag) {\n        encodeTag(data, output);\n        return;\n    }\n    throw new Error(\"Not implemented\");\n}\n/**\n * Like {decodeCBOR}, but the length of the data is unknown and there is likely\n * more -- possibly unrelated non-CBOR -- data afterwards.\n *\n * Examples:\n *\n * ```ts\n * import {decodePartialCBOR} from './cbor.ts'\n * decodePartialCBOR(new Uint8Array([1, 2, 245, 3, 4]), 2)\n * // returns [true, 1]\n * // It did not decode the leading [1, 2] or trailing [3, 4]\n * ```\n *\n * @param data a data stream to read data from\n * @param index where to start reading in the data stream\n * @returns a tuple of the value followed by bytes read.\n * @throws {Error}\n *   When the data stream ends early or the CBOR data is not well formed\n */\nfunction decodePartialCBOR(data, index) {\n    if (data.byteLength === 0 || data.byteLength <= index || index < 0) {\n        throw new Error(\"No data\");\n    }\n    if (data instanceof Uint8Array) {\n        return decodeNext(new DataView(data.buffer), index);\n    }\n    else if (data instanceof ArrayBuffer) {\n        return decodeNext(new DataView(data), index);\n    }\n    // otherwise, it is a data view\n    return decodeNext(data, index);\n}\n/**\n * Decode CBOR data from a binary stream\n *\n * The entire data stream from [0, length) will be consumed.\n * If you require a partial decoding, see {decodePartialCBOR}.\n *\n * Examples:\n *\n * ```ts\n * import {decodeCBOR, CBORTag, CBORType} from './cbor.ts'\n * decodeCBOR(new Uint8Array([162, 99, 107, 101, 121, 101, 118, 97, 108, 117, 101, 1, 109, 97, 110, 111, 116, 104, 101, 114, 32, 118, 97, 108, 117, 101]));\n * // returns new Map<string | number, CBORType>([\n * //   [\"key\", \"value\"],\n * //   [1, \"another value\"]\n * // ]);\n *\n * const taggedItem = new Uint8Array([217, 4, 210, 101, 104, 101, 108, 108, 111]);\n * decodeCBOR(new DataView(taggedItem.buffer))\n * // returns new CBORTag(1234, \"hello\")\n * ```\n *\n * @param data a data stream, multiple types are supported\n * @returns\n */\nfunction decodeCBOR(data) {\n    const [value, length] = decodePartialCBOR(data, 0);\n    if (length !== data.byteLength) {\n        throw new Error(`Data was decoded, but the whole stream was not processed ${length} != ${data.byteLength}`);\n    }\n    return value;\n}\n/**\n * Encode a supported structure to a CBOR byte string.\n *\n * Example:\n *\n * ```ts\n * import {encodeCBOR, CBORType, CBORTag} from './cbor.ts'\n * encodeCBOR(new Map<string | number, CBORType>([\n *   [\"key\", \"value\"],\n *   [1, \"another value\"]\n * ]));\n * // returns new Uint8Array([162, 99, 107, 101, 121, 101, 118, 97, 108, 117, 101, 1, 109, 97, 110, 111, 116, 104, 101, 114, 32 118, 97, 108, 117, 101])\n *\n * encodeCBOR(new CBORTag(1234, \"hello\"))\n * // returns new UInt8Array([217, 4, 210, 101, 104, 101, 108, 108, 111])\n * ```\n *\n * @param data Data to encode\n * @returns A byte string as a Uint8Array\n * @throws Error\n *   if unsupported data is found during encoding\n */\nfunction encodeCBOR(data) {\n    const results = [];\n    encodePartialCBOR(data, results);\n    let length = 0;\n    for (const result of results) {\n        if (typeof result == \"number\") {\n            length += 1;\n        }\n        else {\n            length += result.length;\n        }\n    }\n    const output = new Uint8Array(length);\n    let index = 0;\n    for (const result of results) {\n        if (typeof result == \"number\") {\n            output[index] = result;\n            index += 1;\n        }\n        else {\n            output.set(result, index);\n            index += result.length;\n        }\n    }\n    return output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxldmlzY2h1Y2svdGlueS1jYm9yL2VzbS9jYm9yL2Nib3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeVA7QUFDelA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrREFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsK0RBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtEQUFZO0FBQ2pEO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0RBQVk7QUFDakQ7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJhdXRobi1hcHAvLi9ub2RlX21vZHVsZXMvQGxldmlzY2h1Y2svdGlueS1jYm9yL2VzbS9jYm9yL2Nib3IuanM/OWMxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWNvZGVMZW5ndGgsIGVuY29kZUxlbmd0aCwgTUFKT1JfVFlQRV9BUlJBWSwgTUFKT1JfVFlQRV9CWVRFX1NUUklORywgTUFKT1JfVFlQRV9NQVAsIE1BSk9SX1RZUEVfTkVHQVRJVkVfSU5URUdFUiwgTUFKT1JfVFlQRV9TSU1QTEVfT1JfRkxPQVQsIE1BSk9SX1RZUEVfVEFHLCBNQUpPUl9UWVBFX1RFWFRfU1RSSU5HLCBNQUpPUl9UWVBFX1VOU0lHTkVEX0lOVEVHRVIsIH0gZnJvbSBcIi4vY2Jvcl9pbnRlcm5hbC5qc1wiO1xuLyoqXG4gKiBBIHZhbHVlIHdoaWNoIGlzIHdyYXBwZWQgd2l0aCBhIENCT1IgVGFnLlxuICogU2V2ZXJhbCB0YWdzIGFyZSByZWdpc3RlcmVkIHdpdGggZGVmaW5lZCBtZWFuaW5ncyBsaWtlIDAgZm9yIGEgZGF0ZSBzdHJpbmcuXG4gKiBUaGVzZSBtZWFuaW5ncyBhcmUgKipub3QgaW50ZXJwcmV0ZWQqKiB3aGVuIGRlY29kZWQgb3IgZW5jb2RlZC5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGFuIGltbXV0YWJsZSByZWNvcmQuXG4gKiBJZiB0aGUgdGFnIG51bWJlciBvciB2YWx1ZSBuZWVkcyB0byBjaGFuZ2UsIHRoZW4gY29uc3RydWN0IGEgbmV3IHRhZ1xuICovXG5leHBvcnQgY2xhc3MgQ0JPUlRhZyB7XG4gICAgLyoqXG4gICAgICogV3JhcCBhIHZhbHVlIHdpdGggYSB0YWcgbnVtYmVyLlxuICAgICAqIFdoZW4gZW5jb2RlZCwgdGhpcyB0YWcgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFnIFRhZyBudW1iZXJcbiAgICAgKiBAcGFyYW0gdmFsdWUgV3JhcHBlZCB2YWx1ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhZywgdmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnVmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50YWdJZCA9IHRhZztcbiAgICAgICAgdGhpcy50YWdWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSB0YWcgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IHRhZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIHZhbHVlXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWdWYWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWNvZGVVbnNpZ25lZEludGVnZXIoZGF0YSwgYXJndW1lbnQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGRlY29kZUxlbmd0aChkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xufVxuZnVuY3Rpb24gZGVjb2RlTmVnYXRpdmVJbnRlZ2VyKGRhdGEsIGFyZ3VtZW50LCBpbmRleCkge1xuICAgIGNvbnN0IFt2YWx1ZSwgbGVuZ3RoXSA9IGRlY29kZVVuc2lnbmVkSW50ZWdlcihkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgIHJldHVybiBbLXZhbHVlIC0gMSwgbGVuZ3RoXTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJ5dGVTdHJpbmcoZGF0YSwgYXJndW1lbnQsIGluZGV4KSB7XG4gICAgY29uc3QgW2xlbmd0aFZhbHVlLCBsZW5ndGhDb25zdW1lZF0gPSBkZWNvZGVMZW5ndGgoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICBjb25zdCBkYXRhU3RhcnRJbmRleCA9IGluZGV4ICsgbGVuZ3RoQ29uc3VtZWQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIuc2xpY2UoZGF0YVN0YXJ0SW5kZXgsIGRhdGFTdGFydEluZGV4ICsgbGVuZ3RoVmFsdWUpKSxcbiAgICAgICAgbGVuZ3RoQ29uc3VtZWQgKyBsZW5ndGhWYWx1ZSxcbiAgICBdO1xufVxuY29uc3QgVEVYVF9ERUNPREVSID0gbmV3IFRleHREZWNvZGVyKCk7XG5mdW5jdGlvbiBkZWNvZGVTdHJpbmcoZGF0YSwgYXJndW1lbnQsIGluZGV4KSB7XG4gICAgY29uc3QgW3ZhbHVlLCBsZW5ndGhdID0gZGVjb2RlQnl0ZVN0cmluZyhkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgIHJldHVybiBbVEVYVF9ERUNPREVSLmRlY29kZSh2YWx1ZSksIGxlbmd0aF07XG59XG5mdW5jdGlvbiBkZWNvZGVBcnJheShkYXRhLCBhcmd1bWVudCwgaW5kZXgpIHtcbiAgICBpZiAoYXJndW1lbnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtbXSwgMV07XG4gICAgfVxuICAgIGNvbnN0IFtsZW5ndGgsIGxlbmd0aENvbnN1bWVkXSA9IGRlY29kZUxlbmd0aChkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgIGxldCBjb25zdW1lZExlbmd0aCA9IGxlbmd0aENvbnN1bWVkO1xuICAgIGNvbnN0IHZhbHVlID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByZW1haW5pbmdEYXRhTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoIC0gaW5kZXggLSBjb25zdW1lZExlbmd0aDtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0RhdGFMZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgbm90IHN1cHBvcnRlZCBvciB3ZWxsIGZvcm1lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbZGVjb2RlZFZhbHVlLCBjb25zdW1lZF0gPSBkZWNvZGVOZXh0KGRhdGEsIGluZGV4ICsgY29uc3VtZWRMZW5ndGgpO1xuICAgICAgICB2YWx1ZS5wdXNoKGRlY29kZWRWYWx1ZSk7XG4gICAgICAgIGNvbnN1bWVkTGVuZ3RoICs9IGNvbnN1bWVkO1xuICAgIH1cbiAgICByZXR1cm4gW3ZhbHVlLCBjb25zdW1lZExlbmd0aF07XG59XG5jb25zdCBNQVBfRVJST1IgPSBcIk1hcCBpcyBub3Qgc3VwcG9ydGVkIG9yIHdlbGwgZm9ybWVkXCI7XG5mdW5jdGlvbiBkZWNvZGVNYXAoZGF0YSwgYXJndW1lbnQsIGluZGV4KSB7XG4gICAgaWYgKGFyZ3VtZW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbbmV3IE1hcCgpLCAxXTtcbiAgICB9XG4gICAgY29uc3QgW2xlbmd0aCwgbGVuZ3RoQ29uc3VtZWRdID0gZGVjb2RlTGVuZ3RoKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgbGV0IGNvbnN1bWVkTGVuZ3RoID0gbGVuZ3RoQ29uc3VtZWQ7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJlbWFpbmluZ0RhdGFMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggLSBpbmRleCAtIGNvbnN1bWVkTGVuZ3RoO1xuICAgICAgICBpZiAocmVtYWluaW5nRGF0YUxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTUFQX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb2FkIGtleVxuICAgICAgICBjb25zdCBba2V5LCBrZXlDb25zdW1lZF0gPSBkZWNvZGVOZXh0KGRhdGEsIGluZGV4ICsgY29uc3VtZWRMZW5ndGgpO1xuICAgICAgICBjb25zdW1lZExlbmd0aCArPSBrZXlDb25zdW1lZDtcbiAgICAgICAgcmVtYWluaW5nRGF0YUxlbmd0aCAtPSBrZXlDb25zdW1lZDtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGVyZSdzIGVub3VnaCB0byBoYXZlIGEgdmFsdWVcbiAgICAgICAgaWYgKHJlbWFpbmluZ0RhdGFMZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1BUF9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVjaG5pY2FsbHkgQ0JPUiBtYXBzIGNhbiBoYXZlIGFueSB0eXBlIGFzIHRoZSBrZXksIGFuZCBzbyBjYW4gSlMgTWFwc1xuICAgICAgICAvLyBIb3dldmVyLCBKUyBNYXBzIGNhbiBvbmx5IHJlZmVyZW5jZSBzdWNoIGtleXMgYXMgcmVmZXJlbmNlcyB3aGljaCB3b3VsZFxuICAgICAgICAvLyByZXF1aXJlIGtleSBpdGVyYXRpb24gYW5kIHBhdHRlcm4gbWF0Y2hpbmcuXG4gICAgICAgIC8vIEZvciBzaW1wbGljaXR5LCBzaW5jZSBzdWNoIGtleXMgYXJlIG5vdCBpbiB1c2Ugd2l0aCBXZWJBdXRobiwgdGhpc1xuICAgICAgICAvLyBjYXBhYmlsaXR5IGlzIG5vdCBpbXBsZW1lbnRlZCBhbmQgdGhlIHR5cGVzIGFyZSByZXN0cmljdGVkIHRvIHN0cmluZ3NcbiAgICAgICAgLy8gYW5kIG51bWJlcnMuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBrZXkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNQVBfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENCT1IgTWFwcyBhcmUgbm90IHdlbGwgZm9ybWVkIGlmIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5c1xuICAgICAgICBpZiAocmVzdWx0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTUFQX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb2FkIHZhbHVlXG4gICAgICAgIGNvbnN0IFt2YWx1ZSwgdmFsdWVDb25zdW1lZF0gPSBkZWNvZGVOZXh0KGRhdGEsIGluZGV4ICsgY29uc3VtZWRMZW5ndGgpO1xuICAgICAgICBjb25zdW1lZExlbmd0aCArPSB2YWx1ZUNvbnN1bWVkO1xuICAgICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gW3Jlc3VsdCwgY29uc3VtZWRMZW5ndGhdO1xufVxuZnVuY3Rpb24gZGVjb2RlRmxvYXQxNihkYXRhLCBpbmRleCkge1xuICAgIGlmIChpbmRleCArIDMgPiBkYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ0JPUiBzdHJlYW0gZW5kZWQgYmVmb3JlIGVuZCBvZiBGbG9hdCAxNlwiKTtcbiAgICB9XG4gICAgLy8gU2tpcCB0aGUgZmlyc3QgYnl0ZVxuICAgIGNvbnN0IHJlc3VsdCA9IGRhdGEuZ2V0VWludDE2KGluZGV4ICsgMSwgZmFsc2UpO1xuICAgIC8vIEEgbWluaW1hbCBzZWxlY3Rpb24gb2Ygc3VwcG9ydGVkIHZhbHVlc1xuICAgIGlmIChyZXN1bHQgPT0gMHg3YzAwKSB7XG4gICAgICAgIHJldHVybiBbSW5maW5pdHksIDNdO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgPT0gMHg3ZTAwKSB7XG4gICAgICAgIHJldHVybiBbTmFOLCAzXTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdWx0ID09IDB4ZmMwMCkge1xuICAgICAgICByZXR1cm4gWy1JbmZpbml0eSwgM107XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZsb2F0MTYgZGF0YSBpcyB1bnN1cHBvcnRlZFwiKTtcbn1cbmZ1bmN0aW9uIGRlY29kZUZsb2F0MzIoZGF0YSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggKyA1ID4gZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNCT1Igc3RyZWFtIGVuZGVkIGJlZm9yZSBlbmQgb2YgRmxvYXQgMzJcIik7XG4gICAgfVxuICAgIC8vIFNraXAgdGhlIGZpcnN0IGJ5dGVcbiAgICBjb25zdCByZXN1bHQgPSBkYXRhLmdldEZsb2F0MzIoaW5kZXggKyAxLCBmYWxzZSk7XG4gICAgLy8gRmlyc3QgYnl0ZSArIDQgYnl0ZSBmbG9hdFxuICAgIHJldHVybiBbcmVzdWx0LCA1XTtcbn1cbmZ1bmN0aW9uIGRlY29kZUZsb2F0NjQoZGF0YSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggKyA5ID4gZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNCT1Igc3RyZWFtIGVuZGVkIGJlZm9yZSBlbmQgb2YgRmxvYXQgNjRcIik7XG4gICAgfVxuICAgIC8vIFNraXAgdGhlIGZpcnN0IGJ5dGVcbiAgICBjb25zdCByZXN1bHQgPSBkYXRhLmdldEZsb2F0NjQoaW5kZXggKyAxLCBmYWxzZSk7XG4gICAgLy8gRmlyc3QgYnl0ZSArIDggYnl0ZSBmbG9hdFxuICAgIHJldHVybiBbcmVzdWx0LCA5XTtcbn1cbmZ1bmN0aW9uIGRlY29kZVRhZyhkYXRhLCBhcmd1bWVudCwgaW5kZXgpIHtcbiAgICBjb25zdCBbdGFnLCB0YWdCeXRlc10gPSBkZWNvZGVMZW5ndGgoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICBjb25zdCBbdmFsdWUsIHZhbHVlQnl0ZXNdID0gZGVjb2RlTmV4dChkYXRhLCBpbmRleCArIHRhZ0J5dGVzKTtcbiAgICByZXR1cm4gW25ldyBDQk9SVGFnKHRhZywgdmFsdWUpLCB0YWdCeXRlcyArIHZhbHVlQnl0ZXNdO1xufVxuZnVuY3Rpb24gZGVjb2RlTmV4dChkYXRhLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSBkYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ0JPUiBzdHJlYW0gZW5kZWQgYmVmb3JlIHRhZyB2YWx1ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZSA9IGRhdGEuZ2V0VWludDgoaW5kZXgpO1xuICAgIGNvbnN0IG1ham9yVHlwZSA9IGJ5dGUgPj4gNTtcbiAgICBjb25zdCBhcmd1bWVudCA9IGJ5dGUgJiAweDFmO1xuICAgIHN3aXRjaCAobWFqb3JUeXBlKSB7XG4gICAgICAgIGNhc2UgTUFKT1JfVFlQRV9VTlNJR05FRF9JTlRFR0VSOiB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlVW5zaWduZWRJbnRlZ2VyKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNQUpPUl9UWVBFX05FR0FUSVZFX0lOVEVHRVI6IHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVOZWdhdGl2ZUludGVnZXIoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1BSk9SX1RZUEVfQllURV9TVFJJTkc6IHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVCeXRlU3RyaW5nKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNQUpPUl9UWVBFX1RFWFRfU1RSSU5HOiB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlU3RyaW5nKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNQUpPUl9UWVBFX0FSUkFZOiB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlQXJyYXkoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1BSk9SX1RZUEVfTUFQOiB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlTWFwKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNQUpPUl9UWVBFX1RBRzoge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVRhZyhkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTUFKT1JfVFlQRV9TSU1QTEVfT1JfRkxPQVQ6IHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAxXTtcbiAgICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsIDFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbnVsbCwgMV07XG4gICAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIDFdO1xuICAgICAgICAgICAgICAgIC8vIDI0OiBTaW1wbGUgdmFsdWUgKHZhbHVlIDMyLi4yNTUgaW4gZm9sbG93aW5nIGJ5dGUpXG4gICAgICAgICAgICAgICAgY2FzZSAyNTogLy8gSUVFRSA3NTQgSGFsZi1QcmVjaXNpb24gRmxvYXQgKDE2IGJpdHMgZm9sbG93KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlRmxvYXQxNihkYXRhLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY2FzZSAyNjogLy8gSUVFRSA3NTQgU2luZ2xlLVByZWNpc2lvbiBGbG9hdCAoMzIgYml0cyBmb2xsb3cpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVGbG9hdDMyKGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBjYXNlIDI3OiAvLyBJRUVFIDc1NCBEb3VibGUtUHJlY2lzaW9uIEZsb2F0ICg2NCBiaXRzIGZvbGxvdylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZUZsb2F0NjQoZGF0YSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIC8vIDI4LTMwOiBSZXNlcnZlZCwgbm90IHdlbGwtZm9ybWVkIGluIHRoZSBwcmVzZW50IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgLy8gMzE6IFwiYnJlYWtcIiBzdG9wIGNvZGUgZm9yIGluZGVmaW5pdGUtbGVuZ3RoIGl0ZW1zXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvciBub3Qgd2VsbCBmb3JtZWQgYXQgJHtpbmRleH1gKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVNpbXBsZShkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIDB4ZjU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiAweGY0O1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAweGY2O1xuICAgIH1cbiAgICAvLyBFbHNlIHVuZGVmaW5lZFxuICAgIHJldHVybiAweGY3O1xufVxuZnVuY3Rpb24gZW5jb2RlRmxvYXQoZGF0YSkge1xuICAgIGlmIChNYXRoLmZyb3VuZChkYXRhKSA9PSBkYXRhIHx8ICFOdW1iZXIuaXNGaW5pdGUoZGF0YSkgfHwgTnVtYmVyLmlzTmFOKGRhdGEpKSB7XG4gICAgICAgIC8vIEZsb2F0MzJcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoNSk7XG4gICAgICAgIG91dHB1dFswXSA9IDB4ZmE7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcob3V0cHV0LmJ1ZmZlcik7XG4gICAgICAgIHZpZXcuc2V0RmxvYXQzMigxLCBkYXRhLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBGbG9hdDY0XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KDkpO1xuICAgICAgICBvdXRwdXRbMF0gPSAweGZiO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KG91dHB1dC5idWZmZXIpO1xuICAgICAgICB2aWV3LnNldEZsb2F0NjQoMSwgZGF0YSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuY29kZU51bWJlcihkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKGRhdGEpKSB7XG4gICAgICAgICAgICAvLyBFbmNvZGUgaW50ZWdlclxuICAgICAgICAgICAgaWYgKGRhdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZUxlbmd0aChNQUpPUl9UWVBFX05FR0FUSVZFX0lOVEVHRVIsIE1hdGguYWJzKGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVMZW5ndGgoTUFKT1JfVFlQRV9VTlNJR05FRF9JTlRFR0VSLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2VuY29kZUZsb2F0KGRhdGEpXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChkYXRhIDwgMG4pIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVMZW5ndGgoTUFKT1JfVFlQRV9ORUdBVElWRV9JTlRFR0VSLCBkYXRhICogLTFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVMZW5ndGgoTUFKT1JfVFlQRV9VTlNJR05FRF9JTlRFR0VSLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IEVOQ09ERVIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhkYXRhLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQucHVzaCguLi5lbmNvZGVMZW5ndGgoTUFKT1JfVFlQRV9URVhUX1NUUklORywgZGF0YS5sZW5ndGgpKTtcbiAgICBvdXRwdXQucHVzaChFTkNPREVSLmVuY29kZShkYXRhKSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhkYXRhLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQucHVzaCguLi5lbmNvZGVMZW5ndGgoTUFKT1JfVFlQRV9CWVRFX1NUUklORywgZGF0YS5sZW5ndGgpKTtcbiAgICBvdXRwdXQucHVzaChkYXRhKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUFycmF5KGRhdGEsIG91dHB1dCkge1xuICAgIG91dHB1dC5wdXNoKC4uLmVuY29kZUxlbmd0aChNQUpPUl9UWVBFX0FSUkFZLCBkYXRhLmxlbmd0aCkpO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBkYXRhKSB7XG4gICAgICAgIGVuY29kZVBhcnRpYWxDQk9SKGVsZW1lbnQsIG91dHB1dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5jb2RlTWFwKGRhdGEsIG91dHB1dCkge1xuICAgIG91dHB1dC5wdXNoKG5ldyBVaW50OEFycmF5KGVuY29kZUxlbmd0aChNQUpPUl9UWVBFX01BUCwgZGF0YS5zaXplKSkpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGRhdGEuZW50cmllcygpKSB7XG4gICAgICAgIGVuY29kZVBhcnRpYWxDQk9SKGtleSwgb3V0cHV0KTtcbiAgICAgICAgZW5jb2RlUGFydGlhbENCT1IodmFsdWUsIG91dHB1dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5jb2RlVGFnKHRhZywgb3V0cHV0KSB7XG4gICAgb3V0cHV0LnB1c2goLi4uZW5jb2RlTGVuZ3RoKE1BSk9SX1RZUEVfVEFHLCB0YWcudGFnKSk7XG4gICAgZW5jb2RlUGFydGlhbENCT1IodGFnLnZhbHVlLCBvdXRwdXQpO1xufVxuZnVuY3Rpb24gZW5jb2RlUGFydGlhbENCT1IoZGF0YSwgb3V0cHV0KSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09IFwiYm9vbGVhblwiIHx8IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goZW5jb2RlU2ltcGxlKGRhdGEpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZGF0YSA9PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKC4uLmVuY29kZU51bWJlcihkYXRhKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZW5jb2RlU3RyaW5nKGRhdGEsIG91dHB1dCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGVuY29kZUJ5dGVzKGRhdGEsIG91dHB1dCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgZW5jb2RlQXJyYXkoZGF0YSwgb3V0cHV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBlbmNvZGVNYXAoZGF0YSwgb3V0cHV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIENCT1JUYWcpIHtcbiAgICAgICAgZW5jb2RlVGFnKGRhdGEsIG91dHB1dCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xufVxuLyoqXG4gKiBMaWtlIHtkZWNvZGVDQk9SfSwgYnV0IHRoZSBsZW5ndGggb2YgdGhlIGRhdGEgaXMgdW5rbm93biBhbmQgdGhlcmUgaXMgbGlrZWx5XG4gKiBtb3JlIC0tIHBvc3NpYmx5IHVucmVsYXRlZCBub24tQ0JPUiAtLSBkYXRhIGFmdGVyd2FyZHMuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7ZGVjb2RlUGFydGlhbENCT1J9IGZyb20gJy4vY2Jvci50cydcbiAqIGRlY29kZVBhcnRpYWxDQk9SKG5ldyBVaW50OEFycmF5KFsxLCAyLCAyNDUsIDMsIDRdKSwgMilcbiAqIC8vIHJldHVybnMgW3RydWUsIDFdXG4gKiAvLyBJdCBkaWQgbm90IGRlY29kZSB0aGUgbGVhZGluZyBbMSwgMl0gb3IgdHJhaWxpbmcgWzMsIDRdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZGF0YSBhIGRhdGEgc3RyZWFtIHRvIHJlYWQgZGF0YSBmcm9tXG4gKiBAcGFyYW0gaW5kZXggd2hlcmUgdG8gc3RhcnQgcmVhZGluZyBpbiB0aGUgZGF0YSBzdHJlYW1cbiAqIEByZXR1cm5zIGEgdHVwbGUgb2YgdGhlIHZhbHVlIGZvbGxvd2VkIGJ5IGJ5dGVzIHJlYWQuXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqICAgV2hlbiB0aGUgZGF0YSBzdHJlYW0gZW5kcyBlYXJseSBvciB0aGUgQ0JPUiBkYXRhIGlzIG5vdCB3ZWxsIGZvcm1lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUGFydGlhbENCT1IoZGF0YSwgaW5kZXgpIHtcbiAgICBpZiAoZGF0YS5ieXRlTGVuZ3RoID09PSAwIHx8IGRhdGEuYnl0ZUxlbmd0aCA8PSBpbmRleCB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZGF0YVwiKTtcbiAgICB9XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVOZXh0KG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlciksIGluZGV4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVOZXh0KG5ldyBEYXRhVmlldyhkYXRhKSwgaW5kZXgpO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UsIGl0IGlzIGEgZGF0YSB2aWV3XG4gICAgcmV0dXJuIGRlY29kZU5leHQoZGF0YSwgaW5kZXgpO1xufVxuLyoqXG4gKiBEZWNvZGUgQ0JPUiBkYXRhIGZyb20gYSBiaW5hcnkgc3RyZWFtXG4gKlxuICogVGhlIGVudGlyZSBkYXRhIHN0cmVhbSBmcm9tIFswLCBsZW5ndGgpIHdpbGwgYmUgY29uc3VtZWQuXG4gKiBJZiB5b3UgcmVxdWlyZSBhIHBhcnRpYWwgZGVjb2RpbmcsIHNlZSB7ZGVjb2RlUGFydGlhbENCT1J9LlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge2RlY29kZUNCT1IsIENCT1JUYWcsIENCT1JUeXBlfSBmcm9tICcuL2Nib3IudHMnXG4gKiBkZWNvZGVDQk9SKG5ldyBVaW50OEFycmF5KFsxNjIsIDk5LCAxMDcsIDEwMSwgMTIxLCAxMDEsIDExOCwgOTcsIDEwOCwgMTE3LCAxMDEsIDEsIDEwOSwgOTcsIDExMCwgMTExLCAxMTYsIDEwNCwgMTAxLCAxMTQsIDMyLCAxMTgsIDk3LCAxMDgsIDExNywgMTAxXSkpO1xuICogLy8gcmV0dXJucyBuZXcgTWFwPHN0cmluZyB8IG51bWJlciwgQ0JPUlR5cGU+KFtcbiAqIC8vICAgW1wia2V5XCIsIFwidmFsdWVcIl0sXG4gKiAvLyAgIFsxLCBcImFub3RoZXIgdmFsdWVcIl1cbiAqIC8vIF0pO1xuICpcbiAqIGNvbnN0IHRhZ2dlZEl0ZW0gPSBuZXcgVWludDhBcnJheShbMjE3LCA0LCAyMTAsIDEwMSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTFdKTtcbiAqIGRlY29kZUNCT1IobmV3IERhdGFWaWV3KHRhZ2dlZEl0ZW0uYnVmZmVyKSlcbiAqIC8vIHJldHVybnMgbmV3IENCT1JUYWcoMTIzNCwgXCJoZWxsb1wiKVxuICogYGBgXG4gKlxuICogQHBhcmFtIGRhdGEgYSBkYXRhIHN0cmVhbSwgbXVsdGlwbGUgdHlwZXMgYXJlIHN1cHBvcnRlZFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUNCT1IoZGF0YSkge1xuICAgIGNvbnN0IFt2YWx1ZSwgbGVuZ3RoXSA9IGRlY29kZVBhcnRpYWxDQk9SKGRhdGEsIDApO1xuICAgIGlmIChsZW5ndGggIT09IGRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGEgd2FzIGRlY29kZWQsIGJ1dCB0aGUgd2hvbGUgc3RyZWFtIHdhcyBub3QgcHJvY2Vzc2VkICR7bGVuZ3RofSAhPSAke2RhdGEuYnl0ZUxlbmd0aH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBFbmNvZGUgYSBzdXBwb3J0ZWQgc3RydWN0dXJlIHRvIGEgQ0JPUiBieXRlIHN0cmluZy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge2VuY29kZUNCT1IsIENCT1JUeXBlLCBDQk9SVGFnfSBmcm9tICcuL2Nib3IudHMnXG4gKiBlbmNvZGVDQk9SKG5ldyBNYXA8c3RyaW5nIHwgbnVtYmVyLCBDQk9SVHlwZT4oW1xuICogICBbXCJrZXlcIiwgXCJ2YWx1ZVwiXSxcbiAqICAgWzEsIFwiYW5vdGhlciB2YWx1ZVwiXVxuICogXSkpO1xuICogLy8gcmV0dXJucyBuZXcgVWludDhBcnJheShbMTYyLCA5OSwgMTA3LCAxMDEsIDEyMSwgMTAxLCAxMTgsIDk3LCAxMDgsIDExNywgMTAxLCAxLCAxMDksIDk3LCAxMTAsIDExMSwgMTE2LCAxMDQsIDEwMSwgMTE0LCAzMiAxMTgsIDk3LCAxMDgsIDExNywgMTAxXSlcbiAqXG4gKiBlbmNvZGVDQk9SKG5ldyBDQk9SVGFnKDEyMzQsIFwiaGVsbG9cIikpXG4gKiAvLyByZXR1cm5zIG5ldyBVSW50OEFycmF5KFsyMTcsIDQsIDIxMCwgMTAxLCAxMDQsIDEwMSwgMTA4LCAxMDgsIDExMV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZGF0YSBEYXRhIHRvIGVuY29kZVxuICogQHJldHVybnMgQSBieXRlIHN0cmluZyBhcyBhIFVpbnQ4QXJyYXlcbiAqIEB0aHJvd3MgRXJyb3JcbiAqICAgaWYgdW5zdXBwb3J0ZWQgZGF0YSBpcyBmb3VuZCBkdXJpbmcgZW5jb2RpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUNCT1IoZGF0YSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBlbmNvZGVQYXJ0aWFsQ0JPUihkYXRhLCByZXN1bHRzKTtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoICs9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgb3V0cHV0W2luZGV4XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQuc2V0KHJlc3VsdCwgaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggKz0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAJOR_TYPE_ARRAY: () => (/* binding */ MAJOR_TYPE_ARRAY),\n/* harmony export */   MAJOR_TYPE_BYTE_STRING: () => (/* binding */ MAJOR_TYPE_BYTE_STRING),\n/* harmony export */   MAJOR_TYPE_MAP: () => (/* binding */ MAJOR_TYPE_MAP),\n/* harmony export */   MAJOR_TYPE_NEGATIVE_INTEGER: () => (/* binding */ MAJOR_TYPE_NEGATIVE_INTEGER),\n/* harmony export */   MAJOR_TYPE_SIMPLE_OR_FLOAT: () => (/* binding */ MAJOR_TYPE_SIMPLE_OR_FLOAT),\n/* harmony export */   MAJOR_TYPE_TAG: () => (/* binding */ MAJOR_TYPE_TAG),\n/* harmony export */   MAJOR_TYPE_TEXT_STRING: () => (/* binding */ MAJOR_TYPE_TEXT_STRING),\n/* harmony export */   MAJOR_TYPE_UNSIGNED_INTEGER: () => (/* binding */ MAJOR_TYPE_UNSIGNED_INTEGER),\n/* harmony export */   decodeLength: () => (/* binding */ decodeLength),\n/* harmony export */   encodeLength: () => (/* binding */ encodeLength)\n/* harmony export */ });\nfunction decodeLength(data, argument, index) {\n    if (argument < 24) {\n        return [argument, 1];\n    }\n    const remainingDataLength = data.byteLength - index - 1;\n    const view = new DataView(data.buffer, index + 1);\n    let output;\n    let bytes = 0;\n    switch (argument) {\n        case 24: {\n            if (remainingDataLength > 0) {\n                output = view.getUint8(0);\n                bytes = 2;\n            }\n            break;\n        }\n        case 25: {\n            if (remainingDataLength > 1) {\n                output = view.getUint16(0, false);\n                bytes = 3;\n            }\n            break;\n        }\n        case 26: {\n            if (remainingDataLength > 3) {\n                output = view.getUint32(0, false);\n                bytes = 5;\n            }\n            break;\n        }\n        case 27: {\n            if (remainingDataLength > 7) {\n                const bigOutput = view.getBigUint64(0, false);\n                // Bound it to [24, MAX_SAFE_INTEGER], where it is safe\n                // to encode as a javascript number\n                if (bigOutput >= 24n && bigOutput <= Number.MAX_SAFE_INTEGER) {\n                    return [Number(bigOutput), 9];\n                }\n            }\n            break;\n        }\n    }\n    if (output && output >= 24) {\n        return [output, bytes];\n    }\n    throw new Error(\"Length not supported or not well formed\");\n}\nconst MAJOR_TYPE_UNSIGNED_INTEGER = 0;\nconst MAJOR_TYPE_NEGATIVE_INTEGER = 1;\nconst MAJOR_TYPE_BYTE_STRING = 2;\nconst MAJOR_TYPE_TEXT_STRING = 3;\nconst MAJOR_TYPE_ARRAY = 4;\nconst MAJOR_TYPE_MAP = 5;\nconst MAJOR_TYPE_TAG = 6;\nconst MAJOR_TYPE_SIMPLE_OR_FLOAT = 7;\nfunction encodeLength(major, argument) {\n    const majorEncoded = major << 5;\n    if (argument < 0) {\n        throw new Error(\"CBOR Data Item argument must not be negative\");\n    }\n    // Convert to bigint first.\n    // Encode integers around and above 32 bits in big endian / network byte order\n    // is unreliable in javascript.\n    // https://tc39.es/ecma262/#sec-bitwise-shift-operators\n    // Bit shifting operations result in 32 bit signed numbers\n    let bigintArgument;\n    if (typeof argument == \"number\") {\n        if (!Number.isInteger(argument)) {\n            throw new Error(\"CBOR Data Item argument must be an integer\");\n        }\n        bigintArgument = BigInt(argument);\n    }\n    else {\n        bigintArgument = argument;\n    }\n    // Negative 0 is not a thing\n    if (major == MAJOR_TYPE_NEGATIVE_INTEGER) {\n        if (bigintArgument == 0n) {\n            throw new Error(\"CBOR Data Item argument cannot be zero when negative\");\n        }\n        bigintArgument = bigintArgument - 1n;\n    }\n    if (bigintArgument > 18446744073709551615n) {\n        throw new Error(\"CBOR number out of range\");\n    }\n    // Encode into 64 bits and extract the tail\n    const buffer = new Uint8Array(8);\n    const view = new DataView(buffer.buffer);\n    view.setBigUint64(0, bigintArgument, false);\n    if (bigintArgument <= 23) {\n        return [majorEncoded | buffer[7]];\n    }\n    else if (bigintArgument <= 255) {\n        return [majorEncoded | 24, buffer[7]];\n    }\n    else if (bigintArgument <= 65535) {\n        return [majorEncoded | 25, ...buffer.slice(6)];\n    }\n    else if (bigintArgument <= 4294967295) {\n        return [\n            majorEncoded | 26,\n            ...buffer.slice(4),\n        ];\n    }\n    else {\n        return [\n            majorEncoded | 27,\n            ...buffer,\n        ];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxldmlzY2h1Y2svdGlueS1jYm9yL2VzbS9jYm9yL2Nib3JfaW50ZXJuYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmF1dGhuLWFwcC8uL25vZGVfbW9kdWxlcy9AbGV2aXNjaHVjay90aW55LWNib3IvZXNtL2Nib3IvY2Jvcl9pbnRlcm5hbC5qcz82YjIyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBkZWNvZGVMZW5ndGgoZGF0YSwgYXJndW1lbnQsIGluZGV4KSB7XG4gICAgaWYgKGFyZ3VtZW50IDwgMjQpIHtcbiAgICAgICAgcmV0dXJuIFthcmd1bWVudCwgMV07XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbmluZ0RhdGFMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggLSBpbmRleCAtIDE7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlciwgaW5kZXggKyAxKTtcbiAgICBsZXQgb3V0cHV0O1xuICAgIGxldCBieXRlcyA9IDA7XG4gICAgc3dpdGNoIChhcmd1bWVudCkge1xuICAgICAgICBjYXNlIDI0OiB7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nRGF0YUxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB2aWV3LmdldFVpbnQ4KDApO1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjU6IHtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdEYXRhTGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHZpZXcuZ2V0VWludDE2KDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBieXRlcyA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI2OiB7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nRGF0YUxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB2aWV3LmdldFVpbnQzMigwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzoge1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0RhdGFMZW5ndGggPiA3KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmlnT3V0cHV0ID0gdmlldy5nZXRCaWdVaW50NjQoMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIC8vIEJvdW5kIGl0IHRvIFsyNCwgTUFYX1NBRkVfSU5URUdFUl0sIHdoZXJlIGl0IGlzIHNhZmVcbiAgICAgICAgICAgICAgICAvLyB0byBlbmNvZGUgYXMgYSBqYXZhc2NyaXB0IG51bWJlclxuICAgICAgICAgICAgICAgIGlmIChiaWdPdXRwdXQgPj0gMjRuICYmIGJpZ091dHB1dCA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW051bWJlcihiaWdPdXRwdXQpLCA5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3V0cHV0ICYmIG91dHB1dCA+PSAyNCkge1xuICAgICAgICByZXR1cm4gW291dHB1dCwgYnl0ZXNdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggbm90IHN1cHBvcnRlZCBvciBub3Qgd2VsbCBmb3JtZWRcIik7XG59XG5leHBvcnQgY29uc3QgTUFKT1JfVFlQRV9VTlNJR05FRF9JTlRFR0VSID0gMDtcbmV4cG9ydCBjb25zdCBNQUpPUl9UWVBFX05FR0FUSVZFX0lOVEVHRVIgPSAxO1xuZXhwb3J0IGNvbnN0IE1BSk9SX1RZUEVfQllURV9TVFJJTkcgPSAyO1xuZXhwb3J0IGNvbnN0IE1BSk9SX1RZUEVfVEVYVF9TVFJJTkcgPSAzO1xuZXhwb3J0IGNvbnN0IE1BSk9SX1RZUEVfQVJSQVkgPSA0O1xuZXhwb3J0IGNvbnN0IE1BSk9SX1RZUEVfTUFQID0gNTtcbmV4cG9ydCBjb25zdCBNQUpPUl9UWVBFX1RBRyA9IDY7XG5leHBvcnQgY29uc3QgTUFKT1JfVFlQRV9TSU1QTEVfT1JfRkxPQVQgPSA3O1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUxlbmd0aChtYWpvciwgYXJndW1lbnQpIHtcbiAgICBjb25zdCBtYWpvckVuY29kZWQgPSBtYWpvciA8PCA1O1xuICAgIGlmIChhcmd1bWVudCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ0JPUiBEYXRhIEl0ZW0gYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmVcIik7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdG8gYmlnaW50IGZpcnN0LlxuICAgIC8vIEVuY29kZSBpbnRlZ2VycyBhcm91bmQgYW5kIGFib3ZlIDMyIGJpdHMgaW4gYmlnIGVuZGlhbiAvIG5ldHdvcmsgYnl0ZSBvcmRlclxuICAgIC8vIGlzIHVucmVsaWFibGUgaW4gamF2YXNjcmlwdC5cbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWJpdHdpc2Utc2hpZnQtb3BlcmF0b3JzXG4gICAgLy8gQml0IHNoaWZ0aW5nIG9wZXJhdGlvbnMgcmVzdWx0IGluIDMyIGJpdCBzaWduZWQgbnVtYmVyc1xuICAgIGxldCBiaWdpbnRBcmd1bWVudDtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ0JPUiBEYXRhIEl0ZW0gYXJndW1lbnQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJpZ2ludEFyZ3VtZW50ID0gQmlnSW50KGFyZ3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJpZ2ludEFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgfVxuICAgIC8vIE5lZ2F0aXZlIDAgaXMgbm90IGEgdGhpbmdcbiAgICBpZiAobWFqb3IgPT0gTUFKT1JfVFlQRV9ORUdBVElWRV9JTlRFR0VSKSB7XG4gICAgICAgIGlmIChiaWdpbnRBcmd1bWVudCA9PSAwbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ0JPUiBEYXRhIEl0ZW0gYXJndW1lbnQgY2Fubm90IGJlIHplcm8gd2hlbiBuZWdhdGl2ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBiaWdpbnRBcmd1bWVudCA9IGJpZ2ludEFyZ3VtZW50IC0gMW47XG4gICAgfVxuICAgIGlmIChiaWdpbnRBcmd1bWVudCA+IDE4NDQ2NzQ0MDczNzA5NTUxNjE1bikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQk9SIG51bWJlciBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfVxuICAgIC8vIEVuY29kZSBpbnRvIDY0IGJpdHMgYW5kIGV4dHJhY3QgdGhlIHRhaWxcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlci5idWZmZXIpO1xuICAgIHZpZXcuc2V0QmlnVWludDY0KDAsIGJpZ2ludEFyZ3VtZW50LCBmYWxzZSk7XG4gICAgaWYgKGJpZ2ludEFyZ3VtZW50IDw9IDIzKSB7XG4gICAgICAgIHJldHVybiBbbWFqb3JFbmNvZGVkIHwgYnVmZmVyWzddXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmlnaW50QXJndW1lbnQgPD0gMjU1KSB7XG4gICAgICAgIHJldHVybiBbbWFqb3JFbmNvZGVkIHwgMjQsIGJ1ZmZlcls3XV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpZ2ludEFyZ3VtZW50IDw9IDY1NTM1KSB7XG4gICAgICAgIHJldHVybiBbbWFqb3JFbmNvZGVkIHwgMjUsIC4uLmJ1ZmZlci5zbGljZSg2KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpZ2ludEFyZ3VtZW50IDw9IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1ham9yRW5jb2RlZCB8IDI2LFxuICAgICAgICAgICAgLi4uYnVmZmVyLnNsaWNlKDQpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1ham9yRW5jb2RlZCB8IDI3LFxuICAgICAgICAgICAgLi4uYnVmZmVyLFxuICAgICAgICBdO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@levischuck/tiny-cbor/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@levischuck/tiny-cbor/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CBORTag: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.CBORTag),\n/* harmony export */   decodeCBOR: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.decodeCBOR),\n/* harmony export */   decodePartialCBOR: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.decodePartialCBOR),\n/* harmony export */   encodeCBOR: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.encodeCBOR)\n/* harmony export */ });\n/* harmony import */ var _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cbor/cbor.js */ \"(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxldmlzY2h1Y2svdGlueS1jYm9yL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmF1dGhuLWFwcC8uL25vZGVfbW9kdWxlcy9AbGV2aXNjaHVjay90aW55LWNib3IvZXNtL2luZGV4LmpzPzQwZWIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQ0JPUlRhZywgZGVjb2RlQ0JPUiwgZGVjb2RlUGFydGlhbENCT1IsIGVuY29kZUNCT1IsIH0gZnJvbSBcIi4vY2Jvci9jYm9yLmpzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@levischuck/tiny-cbor/esm/index.js\n");

/***/ })

};
;